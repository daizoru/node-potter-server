// Generated by CoffeeScript 1.3.3
(function() {
  var HEIGHT, WIDTH, animate, attributes, buffsize, camera, center, controls, delay, es, frequency, init, mouse, object, onDocumentMouseMove, onWindowResize, render, renderer, resolution, scene, stats, uniforms, vc1;

  renderer = void 0;

  scene = void 0;

  camera = void 0;

  stats = void 0;

  object = void 0;

  uniforms = void 0;

  controls = void 0;

  attributes = void 0;

  vc1 = void 0;

  mouse = void 0;

  center = new THREE.Vector3();

  center.z = -2;

  WIDTH = window.innerWidth;

  HEIGHT = window.innerHeight;

  delay = function(t, f) {
    return setTimeout(f, t);
  };

  resolution = 38;

  frequency = 150;

  buffsize = 1000;

  es = new EventSource("stream?interval=" + frequency + "&buffsize=" + buffsize + "&resolution=" + resolution);

  es.onmessage = function(e) {
    var i, point, points, visible, x, y, z, _i, _len, _results;
    points = JSON.parse(e.data);
    _results = [];
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      point = points[_i];
      x = point[0], y = point[1], z = point[2], visible = point[3];
      i = x + y * resolution + z * resolution * resolution;
      _results.push(attributes.visible.value[i] = visible);
    }
    return _results;
  };

  init = function() {
    var container, dummyMaterial, geometry, gui, i, m, nb_voxels, plane, planeMaterial, scaling, shaderMaterial, values_color, values_size, vertex, vertices, x, y, z, _i, _j, _k;
    camera = new THREE.PerspectiveCamera(80, WIDTH / HEIGHT, 1, 1000);
    camera.position.z = 200;
    scene = new THREE.Scene();
    scene.add(camera);
    attributes = {
      size: {
        type: "f",
        value: []
      },
      visible: {
        type: "f",
        value: []
      },
      ca: {
        type: "c",
        value: []
      }
    };
    uniforms = {
      cell_size: {
        type: "f",
        value: 80.0,
        old_value: -1
      },
      amplitude: {
        type: "f",
        value: 1.0
      },
      color: {
        type: "c",
        value: new THREE.Color(0xffffff)
      },
      texture: {
        type: "t",
        value: 0,
        texture: THREE.ImageUtils.loadTexture("textures/sprites/ball.png")
      }
    };
    uniforms.texture.texture.wrapS = uniforms.texture.texture.wrapT = THREE.RepeatWrapping;
    shaderMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      attributes: attributes,
      vertexShader: document.getElementById("vertexshader").textContent,
      fragmentShader: document.getElementById("fragmentshader").textContent
    });
    geometry = new THREE.Geometry();
    scaling = 200;
    for (x = _i = 0; 0 <= resolution ? _i < resolution : _i > resolution; x = 0 <= resolution ? ++_i : --_i) {
      for (y = _j = 0; 0 <= resolution ? _j < resolution : _j > resolution; y = 0 <= resolution ? ++_j : --_j) {
        for (z = _k = 0; 0 <= resolution ? _k < resolution : _k > resolution; z = 0 <= resolution ? ++_k : --_k) {
          vertex = new THREE.Vector3();
          vertex.x = x;
          vertex.y = y;
          vertex.z = z;
          vertex.multiplyScalar(scaling / resolution);
          geometry.vertices.push(vertex);
        }
      }
    }
    console.log("voxels: " + geometry.vertices.length);
    nb_voxels = geometry.vertices.length;
    m = void 0;
    dummyMaterial = new THREE.MeshFaceMaterial();
    object = new THREE.ParticleSystem(geometry, shaderMaterial);
    object.dynamic = false;
    object.position.x = -100;
    object.position.y = 5;
    object.position.z = -100;
    vertices = object.geometry.vertices;
    values_size = attributes.size.value;
    values_color = attributes.ca.value;
    i = 0;
    while (i < vertices.length) {
      values_size[i] = 80;
      values_color[i] = new THREE.Color(0xffffff);
      values_color[i].setHSV(0.4 + 0.1 * (i / nb_voxels), 0.99, 1.0);
      i++;
    }
    console.log(vertices.length);
    scene.add(object);
    planeMaterial = new THREE.MeshBasicMaterial({
      color: 0x020202,
      opacity: 0.15,
      transparent: true,
      wireframe: true
    });
    plane = new THREE.Mesh(new THREE.PlaneGeometry(300, 300, 16, 16), planeMaterial);
    plane.visible = true;
    scene.add(plane);
    renderer = new THREE.WebGLRenderer({
      clearColor: 0xffffff,
      clearAlpha: 1,
      antialias: true
    });
    renderer.setSize(WIDTH, HEIGHT);
    container = document.getElementById("container");
    container.appendChild(renderer.domElement);
    stats = new Stats();
    stats.domElement.style.position = "absolute";
    stats.domElement.style.top = "0px";
    container.appendChild(stats.domElement);
    gui = new DAT.GUI();
    gui.add(uniforms.cell_size, 'value').name('cell_size').min(2).max(100).step(0.4);
    gui.close();
    mouse = new THREE.Vector3(0, 0, 1);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
    return window.addEventListener("resize", onWindowResize, false);
  };

  onWindowResize = function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    return renderer.setSize(window.innerWidth, window.innerHeight);
  };

  onDocumentMouseMove = function(event) {
    mouse.x = event.clientX - window.innerWidth / 2;
    return mouse.y = event.clientY - window.innerHeight / 2;
  };

  animate = function() {
    requestAnimationFrame(animate);
    render();
    return stats.update();
  };

  render = function() {
    var i;
    camera.position.x += (mouse.x - camera.position.x) * 0.10;
    camera.position.y += (-mouse.y - camera.position.y) * 0.10;
    camera.lookAt(center);
    i = 0;
    while (i < attributes.size.value.length) {
      attributes.size.value[i] = attributes.visible.value[i] * uniforms.cell_size.value;
      i++;
    }
    attributes.size.needsUpdate = true;
    return renderer.render(scene, camera);
  };

  if (!Detector.webgl) {
    Detector.addGetWebGLMessage();
  }

  init();

  animate();

}).call(this);
